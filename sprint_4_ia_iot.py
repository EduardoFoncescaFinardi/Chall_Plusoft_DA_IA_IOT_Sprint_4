# -*- coding: utf-8 -*-
"""SPRINT_4_IA_IOT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i1-CJ2VjiXMA4VieHbxobvtr_LEwTOV7

# **IMPORTS NECESSÁRIOS**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

"""# **PRÉ-PROCESSAMENTO E ANÁLISE DOS DADOS - 1**"""

path = '/content/marketing_campaign.csv'
df = pd.read_csv(path, sep='\t')
pd.set_option('display.max_columns', 29)

df.head(10)

df_sub = df.drop(columns=["ID", "Recency",'Dt_Customer', 'MntWines', 'MntFruits', 'MntMeatProducts', 'MntFishProducts',
                          'MntSweetProducts', 'AcceptedCmp3','MntGoldProds', 'AcceptedCmp4', 'AcceptedCmp5',
                          'AcceptedCmp2', 'AcceptedCmp1', 'Response', 'Z_CostContact', 'Z_Revenue'])
df_sub.head(10)

print("Valores únicos em Education:", df_sub['Education'].unique())
print("Valores únicos em Marital_Status:", df_sub['Marital_Status'].unique())

education_mapping = {
    'Basic': 1,
    '2n Cycle': 2,
    'Graduation': 3,
    'Master': 4,
    'PhD': 5
}

marital_status_mapping = {
    'Single': 1,
    'Married': 2,
    'Together': 3,
    'Divorced': 4,
    'Widow': 5,
    'Alone' : 6,
    'Absurd' : 7,
    'YOLO' : 8
}

df_sub['Education'] = df_sub['Education'].map(education_mapping)
df_sub['Marital_Status'] = df_sub['Marital_Status'].map(marital_status_mapping)

print(df_sub[['Education', 'Marital_Status']].head(10))

df_sub.head(10)

df_sub.info()

df_sub.describe()

from datetime import datetime
year = datetime.today().year
age= year - df_sub['Year_Birth']
df_sub['Age'] = age


df_sub_2 = df_sub.drop(columns=['Year_Birth'])
df_sub_2.head()

df_sub_2.hist(bins=30, figsize=(20, 15))
plt.show()

df_sub_2.plot(kind='box', subplots=True, layout=(4,4), figsize=(15,10))
plt.show()

df_sub_2.plot(kind='box', subplots=True, layout=(4,4), figsize=(15,10))
plt.show()

df_sub_2.query("Income > 140000")

df_sub_3 = df_sub_2.drop([164,617,655,687,1300,1653,2132,2233])

df_sub_3.isnull().sum()

df_sub_3['Income'].fillna(df_sub_3['Income'].mean(), inplace = True)

sns.heatmap(df_sub_3.isnull());

grafico = px.box(df_sub_3, y='Age')
grafico.show()

df_sub_3.loc[df_sub_3['Age'] > 81]

df_sub_4 = df_sub_3.drop([192,239,339])

df_sub_4['Young'] = df_sub_4.apply(lambda x: x['Teenhome'] + x['Kidhome'], axis=1)
df_test = df_sub_4.drop(columns=['Kidhome',	'Teenhome'])
df_test.head(2)

plt.figure(figsize=(10,6))
sns.countplot(y="Young", data=df_test, order=df_test["Young"].value_counts().index)
plt.title("numbers of children");

correlations = df_test.corr()
f, ax = plt.subplots(figsize = (12,12))
sns.heatmap(correlations, annot=True)
correlations.round(2);

plt.figure(figsize=(12, 6))
sns.boxplot(x=pd.cut(df_test['Age'], bins=5), y='NumStorePurchases', data=df_test)
plt.title('Distribuição de Compras em Loja por Faixa Etária')
plt.xlabel('Faixa Etária')
plt.ylabel('Compras em Loja')
plt.show()

plt.figure(figsize=(12, 6))
sns.boxplot(x=pd.cut(df_test['Age'], bins=5), y='NumWebPurchases', data=df_test)
plt.title('Distribuição de Compras na Web por Faixa Etária')
plt.xlabel('Faixa Etária')
plt.ylabel('Compras na Web')
plt.show()

age_bins = pd.cut(df_test['Age'], bins=[20, 30, 40, 50, 60, 70, 80, 90])
store_purchases_by_age = df_test.groupby(age_bins)['NumStorePurchases'].mean()
web_purchases_by_age = df_test.groupby(age_bins)['NumWebPurchases'].mean()

print("Média de Compras em Loja por Faixa Etária:")
print(store_purchases_by_age)

print("\nMédia de Compras na Web por Faixa Etária:")
print(web_purchases_by_age)

# Agrupar por Marital_Status e calcular a média de NumStorePurchases
store_purchases_by_marital_status = df_test.groupby('Marital_Status')['NumStorePurchases'].mean()

# Agrupar por Marital_Status e calcular a média de NumWebPurchases
web_purchases_by_marital_status = df_test.groupby('Marital_Status')['NumWebPurchases'].mean()

# Exibir os resultados
print("Média de Compras em Loja por Estado Civil:")
print(store_purchases_by_marital_status)

print("\nMédia de Compras na Web por Estado Civil:")
print(web_purchases_by_marital_status)

import matplotlib.pyplot as plt
import seaborn as sns

# Configurar o estilo dos gráficos
sns.set(style="whitegrid")

# Criar um DataFrame para facilitar a plotagem
df_grouped = df_test.groupby('Marital_Status').agg({
    'NumStorePurchases': 'mean',
    'NumWebPurchases': 'mean'
}).reset_index()

# Gráfico de barras para NumStorePurchases por Marital_Status
plt.figure(figsize=(10, 5))
sns.barplot(x='Marital_Status', y='NumStorePurchases', data=df_grouped, palette='Blues_d')
plt.title('Média de Compras em Loja por Estado Civil')
plt.xlabel('Estado Civil')
plt.ylabel('Média de Compras em Loja')
plt.xticks(rotation=45)
plt.show()

# Gráfico de barras para NumWebPurchases por Marital_Status
plt.figure(figsize=(10, 5))
sns.barplot(x='Marital_Status', y='NumWebPurchases', data=df_grouped, palette='Greens_d')
plt.title('Média de Compras na Web por Estado Civil')
plt.xlabel('Estado Civil')
plt.ylabel('Média de Compras na Web')
plt.xticks(rotation=45)
plt.show()

"""# **PRÉ-PROCESSAMENTO E ANÁLISE DOS DADOS - 2**"""

# Criar faixas de renda
bins = [0, 20000, 40000, 60000, 80000, 100000]
labels = ['0-20k', '20k-40k', '40k-60k', '60k-80k', '80k-100k']
df_test['Income_Group'] = pd.cut(df_test['Income'], bins=bins, labels=labels, right=False)

# Calcular a média de compras para cada faixa de renda
income_grouped = df_test.groupby('Income_Group').agg({
    'NumStorePurchases': 'mean',
    'NumWebPurchases': 'mean'
}).reset_index()

# Gráfico de barras para NumStorePurchases por faixa de renda
plt.figure(figsize=(10, 5))
sns.barplot(x='Income_Group', y='NumStorePurchases', data=income_grouped, palette='Blues_d')
plt.title('Média de Compras em Loja por Faixa de Renda')
plt.xlabel('Faixa de Renda')
plt.ylabel('Média de Compras em Loja')
plt.show()

# Gráfico de barras para NumWebPurchases por faixa de renda
plt.figure(figsize=(10, 5))
sns.barplot(x='Income_Group', y='NumWebPurchases', data=income_grouped, palette='Greens_d')
plt.title('Média de Compras na Web por Faixa de Renda')
plt.xlabel('Faixa de Renda')
plt.ylabel('Média de Compras na Web')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Supondo que df_test seja o seu DataFrame
# Calcular a média de compras para cada nível de educação
education_grouped = df_test.groupby('Education').agg({
    'NumStorePurchases': 'mean',
    'NumWebPurchases': 'mean'
}).reset_index()

# Gráfico de barras para NumStorePurchases por nível de educação
plt.figure(figsize=(10, 5))
sns.barplot(x='Education', y='NumStorePurchases', data=education_grouped, palette='Blues_d')
plt.title('Média de Compras em Loja por Nível de Educação')
plt.xlabel('Nível de Educação')
plt.ylabel('Média de Compras em Loja')
plt.xticks(rotation=45)
plt.show()

# Gráfico de barras para NumWebPurchases por nível de educação
plt.figure(figsize=(10, 5))
sns.barplot(x='Education', y='NumWebPurchases', data=education_grouped, palette='Greens_d')
plt.title('Média de Compras na Web por Nível de Educação')
plt.xlabel('Nível de Educação')
plt.ylabel('Média de Compras na Web')
plt.xticks(rotation=45)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Configurar o estilo dos gráficos
sns.set(style="whitegrid")

# Criar um DataFrame para facilitar a plotagem
df_grouped = df_test.groupby('Age').agg({
    'NumStorePurchases': 'mean',
    'NumWebPurchases': 'mean'
}).reset_index()

# Gráfico de barras para NumStorePurchases por Age
plt.figure(figsize=(10, 5))
sns.barplot(x='Age', y='NumStorePurchases', data=df_grouped, palette='Blues_d')
plt.title('Média de Compras em Loja por Estado Civil')
plt.xlabel('Estado Civil')
plt.ylabel('Média de Compras em Loja')
plt.xticks(rotation=45)
plt.show()

# Gráfico de barras para NumWebPurchases por Age
plt.figure(figsize=(10, 5))
sns.barplot(x='Age', y='NumWebPurchases', data=df_grouped, palette='Greens_d')
plt.title('Média de Compras na Web por Estado Civil')
plt.xlabel('Estado Civil')
plt.ylabel('Média de Compras na Web')
plt.xticks(rotation=45)
plt.show()

import pandas as pd

# Definir os limites dos bins e os rótulos correspondentes
bins = [18, 30, 55, 80, 100]
labels = [1, 2, 3, 4]  # Usando números para representar os grupos de idade

# Criar a coluna 'Age_Group' com valores numéricos
df_test['Age_Group'] = pd.cut(df_test['Age'], bins=bins, labels=labels, right=False)

# Converter para tipo numérico, preenchendo NaNs com um valor padrão
df_test['Age_Group'] = df_test['Age_Group'].cat.add_categories([0]).fillna(0).astype(int)

# Verificar o resultado
print(df_test[['Age', 'Age_Group']].head(20))

import pandas as pd

# Definir os limites dos bins e os rótulos numéricos correspondentes
bins = [0, 20000, 40000, 60000, 80000, 100000, float('inf')]
labels = [1, 2, 3, 4, 5, 6]  # Incluindo um rótulo adicional para valores acima de 100k

# Criar a coluna 'Income_Group' com valores numéricos
df_test['Income_Group'] = pd.cut(df_test['Income'], bins=bins, labels=labels, right=False)

# Converter a coluna 'Income_Group' para tipo float para lidar com NaNs
df_test['Income_Group'] = df_test['Income_Group'].astype(float)

# Preencher NaNs com um valor padrão, se necessário
df_test['Income_Group'] = df_test['Income_Group'].fillna(0).astype(int)

# Verificar o resultado
print(df_test[['Income', 'Income_Group']].head(20))

# Criar novas features
df_test['TotalPurchases'] = df_test['NumWebPurchases'] + df_test['NumStorePurchases']
df_test['WebToStoreRatio'] = df_test['NumWebPurchases'] / (df_test['NumStorePurchases'] + 1)  # +1 para evitar divisão por zero
print(df_test[['NumWebPurchases', 'NumStorePurchases', 'TotalPurchases', 'WebToStoreRatio']].head())

"""# **DATASET FINAL**"""

df_test.head(20)

"""# **MACHINE LEARNING DE PREDIÇÃO DE COMPRAS**"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report, confusion_matrix

# Supondo que 'df_test' seja o seu DataFrame e 'target' a coluna alvo
X = df_test.drop('NumStorePurchases', axis=1)
y = df_test['NumStorePurchases']

# Dividir os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Normalizar os dados
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

import numpy as np
import pandas as pd
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
import xgboost as xgb
import matplotlib.pyplot as plt
import seaborn as sns

# Supondo que 'df' seja o seu DataFrame
X = df_test.drop('NumStorePurchases', axis=1)
y = df_test['NumStorePurchases']

# Converter colunas categóricas em numéricas
categorical_cols = X.select_dtypes(include=['object']).columns

# Usar OneHotEncoder para colunas categóricas
X = pd.get_dummies(X, columns=categorical_cols, drop_first=True)

# Reindexar as classes antes de dividir os dados
label_encoder = LabelEncoder()
y_encoded = label_encoder.fit_transform(y)

# Dividir os dados em conjuntos de treinamento e teste
X_train, X_test, y_train_encoded, y_test_encoded = train_test_split(X, y_encoded, test_size=0.3, random_state=42)

# Ajustar o modelo XGBoost
xgb_model = xgb.XGBClassifier(
    colsample_bytree=0.8,
    gamma=0.2,
    learning_rate=0.1,
    max_depth=7,
    n_estimators=50,
    subsample=1.0,
    use_label_encoder=False,
    eval_metric='mlogloss',
    random_state=42
)

# Treinar o modelo
xgb_model.fit(X_train, y_train_encoded)

# Fazer previsões
y_pred_xgb = xgb_model.predict(X_test)

# Avaliar o modelo
print("XGBoost Confusion Matrix:")
conf_matrix = confusion_matrix(y_test_encoded, y_pred_xgb)
print(conf_matrix)
print("\nXGBoost Classification Report:")
print(classification_report(y_test_encoded, y_pred_xgb))

# Visualização da Matriz de Confusão
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.title('Matriz de Confusão - XGBoost')
plt.xlabel('Previsto')
plt.ylabel('Verdadeiro')
plt.show()

# Importância das Características
xgb.plot_importance(xgb_model, importance_type='weight', max_num_features=10)
plt.title('Importância das Características - XGBoost')
plt.show()

"""# **MACHINE LEARNING DE CLASSIFICAÇÃO POR GRUPOS**"""

from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

# Normalizar os dados
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Definir o número de clusters
kmeans = KMeans(n_clusters=3, random_state=42)

# Ajustar o modelo
kmeans.fit(X_scaled)

# Obter os rótulos dos clusters
clusters_kmeans = kmeans.labels_

# Adicionar os rótulos ao DataFrame
df_test['Cluster_KMeans'] = clusters_kmeans

# Visualizar os resultados
print(df_test[['NumWebPurchases', 'Cluster_KMeans']].head(20))

print(df_test['Cluster_KMeans'].value_counts())

cluster_summary = df_test.groupby('Cluster_KMeans').mean()
print(cluster_summary)

import matplotlib.pyplot as plt
import seaborn as sns

sns.scatterplot(data=df_test, x='Age', y='NumWebPurchases', hue='Cluster_KMeans', palette='viridis')
plt.title('Clusters de Compras na Web vs idade')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

sns.scatterplot(data=df_test, x='Age', y='NumStorePurchases', hue='Cluster_KMeans', palette='viridis')
plt.title('Compras em Lojas vs Idade')
plt.show()

from sklearn.metrics import silhouette_score

silhouette_avg = silhouette_score(X_scaled, clusters_kmeans)
print(f"Coeficiente de Silhueta: {silhouette_avg}")

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Supondo que 'df_test' seja o seu DataFrame com os clusters já definidos
# Calcular as médias de cada variável por cluster
cluster_summary = df_test.groupby('Cluster_KMeans').mean()

# Remover a coluna 'Income' do resumo
cluster_summary = cluster_summary.drop(columns=['Income', 'Age'])

# Resetar o índice para facilitar a plotagem
cluster_summary = cluster_summary.reset_index()

# Configurar o estilo do seaborn
sns.set(style="whitegrid")

# Criar um gráfico de barras para cada variável
cluster_summary_melted = cluster_summary.melt(id_vars='Cluster_KMeans', var_name='Variável', value_name='Média')

plt.figure(figsize=(12, 8))
sns.barplot(data=cluster_summary_melted, x='Variável', y='Média', hue='Cluster_KMeans', palette='viridis')

# Ajustar o título e os rótulos
plt.title('Médias das Variáveis por Cluster (Excluindo Income e Age)')
plt.xticks(rotation=45)
plt.xlabel('Variável')
plt.ylabel('Média')
plt.legend(title='Cluster')

# Mostrar o gráfico
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Supondo que 'df_test' seja o seu DataFrame com os clusters já definidos
# Calcular as médias de 'Income' por cluster
income_summary = df_test.groupby('Cluster_KMeans')['Income'].mean().reset_index()

# Configurar o estilo do seaborn
sns.set(style="whitegrid")

# Criar um gráfico de barras para 'Income'
plt.figure(figsize=(8, 6))
sns.barplot(data=income_summary, x='Cluster_KMeans', y='Income', palette='viridis')

# Ajustar o título e os rótulos
plt.title('Média de Income por Cluster')
plt.xlabel('Cluster')
plt.ylabel('Média de Income')

# Mostrar o gráfico
plt.tight_layout()
plt.show()

# Calcular as médias de 'Age' por cluster
age_summary = df_test.groupby('Cluster_KMeans')['Age'].mean().reset_index()

# Criar um gráfico de barras para 'Age'
plt.figure(figsize=(8, 6))
sns.barplot(data=age_summary, x='Cluster_KMeans', y='Age', palette='viridis')

# Ajustar o título e os rótulos
plt.title('Média de Age por Cluster')
plt.xlabel('Cluster')
plt.ylabel('Média de Age')

# Mostrar o gráfico
plt.tight_layout()
plt.show()